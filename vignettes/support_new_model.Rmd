---
output: 
  github_document:
    toc: false
    fig_width: 10.08
    fig_height: 6
tags: [r, models, utils, insight]
vignette: >
  %\VignetteIndexEntry{README}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---


```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.path = "README-"
)
```


# Add `insight` Support for New Models

The package has been written with the unknown future in mind, in a flexible way so that implementation of new kinds of models is simple and straightforward.

***Simply follow the steps:***

## 1. Add a `find_formula()` method

If your model is compatible with `stats::formula()` and has only a fixed-effects part, you actually need to do nothing more here.

Else, add a `find_formula()` method for your model-class, that returns a `list` with one or more of the following elements:

* `conditional`, the "fixed effects" part from the model
* `random`, the "random effects" part from the model (or the `id` for gee-models and similar)
* `zero_inflated`, the "fixed effects" part from the zero-inflation component of the model
`zero_inflated_random`, the "random effects" part from the zero-inflation component of the model
* `dispersion`, the dispersion formula
* `instruments`, for fixed-effects regressions like ivreg, felm or plm, the instrumental variables.

The formula-parts for the _random effects_ should _not_ contain random slopes, but only the group factors, and should have following pattern: `~1 | g` or `~1 | g2:g1`.

If your models follows the **lme4**-formula style, you can use helper-functions that extract the relevant parts of your formula. Here is an example of how the formula from `merMod`-objects is extracted:

First, get the formula:

```{r eval=FALSE}
form <- stats::formula(x)
```

Then get the random parts of the formula:

```{r eval=FALSE}
f.random <- lapply(lme4::findbars(form), function(.x) {
  f <- deparse(.x, width.cutoff = 500)
  stats::as.formula(paste0("~", f))
})
```

You may reduce the list with the random effects formula.

```{r eval=FALSE}
if (length(f.random) == 1) {
  f.random <- f.random[[1]]
}
```

Finally, remove the random effects from the fixed effects part.

```{r eval=FALSE}
f.cond <- stats::as.formula(get_fixed_effects(form))
```

Make sure you return no empty or `NULL`-elements. You can do this with `compact_list()`:

```{r eval=FALSE}
compact_list(list(conditional = f.cond, random = f.random))
```

### Examples

Here is an example for a mixed-model with zero-inflation component:

```{r message=FALSE, warning=FALSE}
library(insight)
library(glmmTMB)
data(Salamanders)

m <- glmmTMB(
  count ~ spp + mined + (1|site), 
  zi = ~spp + mined,
  family = nbinom2,
  data = Salamanders
)

find_formula(m)
```

Another example for models with nested random effects:

```{r message=FALSE, warning=FALSE}
library(lme4)
data(sleepstudy)

sleepstudy$mygrp <- sample(1:5, size = 180, replace = TRUE)
sleepstudy$mysubgrp <- NA
for (i in 1:5) {
  filter_group <- sleepstudy$mygrp == i
  sleepstudy$mysubgrp[filter_group] <- sample(1:30, size = sum(filter_group), replace = TRUE)
}

m <- lme4::lmer(
  Reaction ~ Days + (1 | mygrp / mysubgrp) + (1 | Subject),
  data = sleepstudy
)

find_formula(m)
```

